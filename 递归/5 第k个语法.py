# -*- coding: utf-8 -*-
"""
在第一行我们写上一个 0。接下来的每一行，将前一行中的0替换为01，1替换为10。

给定行数 N 和序数 K，返回第 N 行中第 K个字符。（K从1开始）

输入: N = 1, K = 1
输出: 0

输入: N = 2, K = 1
输出: 0

输入: N = 2, K = 2
输出: 1

输入: N = 4, K = 5
输出: 1

解释:
第一行: 0
第二行: 01
第三行: 0110
第四行: 01101001
第五行：0110100110010110
注意：

    N 的范围 [1, 30].
    K 的范围 [1, 2^(N-1)].


通过观察发现
                  0                      K 1
            0         1                 K 2
         0    1     1    0              K 4          3
      0   1  1  0  1  0  0  1           K 8          6
      0   1  0  1  0  1 0  1          1- K%2
      0   1  1  0  1  0  0  1         (1-K%2) ^  N-1的父节点  = N节点的K的值
左子节点和父节点值一致，右子节点和父节点相反
N -1 的 (k + 1)/2 和 N 的 k 是等价的值
如何判断K 的值和父节点的值的位置？  K为1 则等于父  K 为2 则为1 - 父节点
但是找到父节点后怎么判断原来节点偏左还是偏右？  异或操作
0 ^ 1  = 1   1^ 1 = 0   0 ^ 0 = 0   1 ^0 = 1


   (1-K%2) ^  N-1的父节点  = N节点的K的值
递归设计主要内容：
(1-k%2） ^ kthGrammar(N-1,(K+1) /2)

"""


class Solution ( object ):
    def kthGrammar(self, N, K):
        """
        :type N: int
        :type K: int
        :rtype: int
        """
        if (N == 1):
            return 0
        if (K % 2 == 0):
            '''
            4,6
            3,3
            2,2
            1, 1   0
            2, 2  0 if 0 == 0     0 ^ 1
            3 ,3  1 if 0 == 0
            4 ,6  1 if 1 == 0 else 0
            '''
            #父节点self.kthGrammar(N-1,k/2)
        else :
            #父节点self.kthGrammar(N-1,（k+1）/2)





a = Solution()
print(a.kthGrammar(4,6))
